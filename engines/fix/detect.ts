import { GraphSnapshot, FileModule } from "../../schema/types";
import { findPathTo } from "../topology/pathfinder";
import fs from "fs";
import path from "path";

export type FixType = 
  | "missing_route"
  | "unused_file"
  | "missing_doc"
  | "broken_import";

export interface Fix {
  type: FixType;
  severity: "high" | "medium" | "low";
  target: string;
  description: string;
  suggestedPath?: string[];
  action: "create_stub" | "create_file" | "create_doc" | "review";
  skeleton?: string;
}

export interface FixReport {
  fixes: Fix[];
  summary: {
    total: number;
    high: number;
    medium: number;
    low: number;
  };
}

export function detectFixes(snapshot: GraphSnapshot, workspaceRoot: string): FixReport {
  const fixes: Fix[] = [];

  // 1. Missing routes (orphan modules with no entry path)
  const orphans = snapshot.modules.filter((m: FileModule) => {
    const pathResult = findPathTo(m.id, snapshot.modules, snapshot.edges);
    return !pathResult || pathResult.nodes.length === 0;
  });

  orphans.forEach((orphan: FileModule) => {
    fixes.push({
      type: "missing_route",
      severity: "high",
      target: orphan.name,
      description: `Module ${orphan.name} has no route from entry point`,
      suggestedPath: ["cli/cwy.ts", orphan.name],
      action: "create_stub",
      skeleton: generateRouteStub(orphan),
    });
  });

  // 2. Unused files (modules with no incoming or outgoing edges)
  const unused = snapshot.modules.filter((m: FileModule) => {
    const hasIncoming = snapshot.edges.some((e: { to: string }) => e.to === m.id);
    const hasOutgoing = snapshot.edges.some((e: { from: string }) => e.from === m.id);
    return !hasIncoming && !hasOutgoing;
  });

  unused.forEach((u: FileModule) => {
    fixes.push({
      type: "unused_file",
      severity: "medium",
      target: u.path,
      description: `File ${u.path} is not imported or used anywhere`,
      action: "review",
    });
  });

  // 3. Missing docs (README.md, OpenAPI, etc.)
  const readmePath = path.join(workspaceRoot, "README.md");
  if (!fs.existsSync(readmePath)) {
    fixes.push({
      type: "missing_doc",
      severity: "low",
      target: "README.md",
      description: "Project documentation missing",
      action: "create_doc",
      skeleton: generateReadmeSkeleton(snapshot),
    });
  }

  // 4. Broken imports (imports that couldn't be resolved - detected during scan)
  // This would be populated by topology scanner tracking failed resolves
  // For now, we'll leave this as a placeholder for enhancement

  // Calculate summary
  const summary = {
    total: fixes.length,
    high: fixes.filter((f: Fix) => f.severity === "high").length,
    medium: fixes.filter((f: Fix) => f.severity === "medium").length,
    low: fixes.filter((f: Fix) => f.severity === "low").length,
  };

  return { fixes, summary };
}

function generateRouteStub(module: FileModule): string {
  const moduleName = module.name.split("/").pop() || "module";
  const varName = moduleName.replace(/[^a-zA-Z0-9]/g, "");
  
  return `// Auto-generated by CWY (stub only - implement logic)
import * as ${varName} from "../${module.path.replace(/\.ts$/, "")}";

export function register${varName.charAt(0).toUpperCase() + varName.slice(1)}() {
  // TODO: Connect ${module.name} to your application
  // This stub ensures the module is reachable in the graph
  console.log("${module.name} registered");
}
`;
}

function generateReadmeSkeleton(snapshot: GraphSnapshot): string {
  const moduleCount = snapshot.modules.length;
  const edgeCount = snapshot.edges.length;
  
  return `# Project Overview

> Generated by CWY - offline-first system mapping

## Structure

- **Modules**: ${moduleCount}
- **Connections**: ${edgeCount}

## Architecture

\`\`\`
[Generated graph visualization would go here]
\`\`\`

## Getting Started

\`\`\`bash
# Install dependencies
npm install

# Run the application
npm start
\`\`\`

## Documentation

- See \`cwy overview\` for system snapshot
- See \`cwy integrity\` for health checks
- See \`cwy route <target>\` for path tracing

---

*This README was generated by CWY. Update it with your project-specific details.*
`;
}

export function formatFixReport(report: FixReport): string {
  const lines = [
    "FIX REPORT\n",
    `Total fixes: ${report.summary.total} (${report.summary.high} high, ${report.summary.medium} medium, ${report.summary.low} low)\n`,
  ];

  if (report.summary.high > 0) {
    lines.push("High priority:");
    report.fixes
      .filter((f) => f.severity === "high")
      .forEach((f) => {
        lines.push(`  \u2717 ${f.description}`);
        if (f.suggestedPath) {
          lines.push(`     Suggested route: ${f.suggestedPath.join(" â†’ ")}`);
        }
        lines.push(`     Action: ${f.action}\n`);
      });
  }

  if (report.summary.medium > 0) {
    lines.push("Medium priority:");
    report.fixes
      .filter((f) => f.severity === "medium")
      .forEach((f) => {
        lines.push(`  \u26A0  ${f.description}`);
        lines.push(`     Action: ${f.action}\n`);
      });
  }

  if (report.summary.low > 0) {
    lines.push("Low priority:");
    report.fixes
      .filter((f) => f.severity === "low")
      .forEach((f) => {
        lines.push(`  \u2139  ${f.description}`);
        lines.push(`     Action: ${f.action}\n`);
      });
  }

  if (report.summary.total === 0) {
    lines.push("\u2713 No fixes needed - system is healthy!");
  } else {
    lines.push("\nTo apply fixes (creates skeleton files only):");
    lines.push("  cwy fix --apply");
  }

  return lines.join("\n");
}
